### 스크럼 
- 학습 목표 1: 자료구조 & 알고리즘 챕터 읽고 정리
- 학습 목표 2: Base LLM 변경
- 학습 목표 3: 설계 2,3단계 수정

## 배열과 연결 리스트의 차이점

- **배열 (array)**
메모리 공간에서 연속적으로 데이터를 저장.
인덱스를 통한 접근이 간편하다.
배열의 크기는 초기 생성 시에 결정되며 이후에 변경할 수 없다.
- **연결 리스트 (linked list)**
데이터를 포인터로 연결. 첫번째가 헤드(Head), 마지막은 테일(Tail)로 불린다.
노드가 순차적으로 연결된 데이터 구조 → 순차 접근만 가능.
동적 메모리 할당을 사용 → 삽입 및 삭제가 용이.

### 배열과 연결 리스트 중 어떤 상황에서 어떤 데이터 구조 선택?

- 배열은 고정된 크기와 인덱스를 통한 빠른 접근이 필요한 경우에 유용
    - 달력 스케줄 관리
- 연결 리스트는 동적 크기와 삽입/삭제가 빈번한 상황에서 적합
    - 스마트폰 연락처 관리

### 연결 리스트에서 노드를 삭제할 때 메모리 누수 어떻게 방지?

- 노드를 삭제하기 전에 해당 노드와 관련된 포인터를 해제하고, 메모리 해체 함수를 사용하여 노드의 메모리를 반환해야 메모리 누수를 방지할 수 있다.

배열은 메모리상에서 고정된 크기를 가지며 인덱스를 통한 접근이 쉽습니다.
반면에 연결 리스트는 동적인 메모리 할당을 사용하여 데이터 삽입이나 삭제가 효율적인 구조입니다.

## 스택과 큐의 차이점

- 스택
후입선출 (Last in - First out) 방식으로 나중에 들어온 값이 먼저 나가는 구조
접근에 제한이 있는 데이터 구조, 요소는 스택의 맨 위에서만 추가하거나 제거할 수 있다.
- PUSH:  스택에 항목을 추가하는 작업
- POP: 스택에서 항목을 꺼내는 작업
    - 책을 쌓는 것, 새 책은 위로 올릴 수 있고 맨 위에 있는 책만 뺄 수 있음
- 큐
선입선출 (First in - First out) 방식으로 먼저 들어온 값이 먼저 나가는 구조
- Enqueue: 항목을 큐의 뒷부분에 삽입하는 작업
- Dequeue: 앞쪽 항목을 제거하는 작업
    - 편의점의 음료수 배치, 직원은 맨 뒤로 새 음료수 추가하고 손님은 맨앞에 있던 음료수를 가져감

스택은 가장 최근에 추가된 항목을 제거하지만,
큐는 가장 오랫동안 대기한 항목을 제거한다는 점에서 차이가 납니다.

### 스택과 큐의 주요 용도

- 스택
    - 역추적 / 후속 작업 처리
    - 웹 브라우저의 뒤로 가기 버튼
- 큐
    - 대기열 / 순차 처리
    - 프린터 대기열

## 트리 자료구조 - 이진 트리와 이진 탐색 트리의 차이점

- 트리 자료구조: 일련의 연결된 노드가 있는 계층적 구조로 사용되는 추상 데이터 유형
    
    트리 자료구조는 하나의 루트 노드에서 시작해 자식 노드로 뻗어나가는 계층적 구조로,
    폴더 구조나 가족도처럼 위계 관계를 표현할 때 사용됩니다.
    
- **이진 트리 (Binary Tree)**
계층적인 데이터 구조 - 최대 두 개의 자식 노드로 이루어짐
하나의 루트 노드로부터 시작하여 각 노드가 왼쪽 자식노드와 오른쪽 자식노드로 구성
각 자식 노드는 다시 자신의 자식 노드를 가질 수 있음
- **이진 탐색 트리 (Binary Search Tree)**
이진 트리의 효율적인 탐색 능력을 유지하면서 자료의 삽입과 삭제를 빈번하게 수행할 수 있도록 고완된 트리
- 데이터 값(키): 노드에 저장된 값, 이 값은 노드를 정렬된 순서로 유지하는 기준이 됨
- 왼쪽 자식 노드: 현재 노드보다 작은 값을 가지는 노드를 가리키는 포인터
- 오른쪽 자식 노드: 현재 노드보다 큰 값을 가지는 노드를 가리키는 포인터
    
    이진 탐색 트리는 루트 노드를 기준으로 작은 값은 왼쪽 서브 트리에, 큰 값은 오른쪽 서브 트리에 위치하는 정렬된 트리구조입니다.
    따라서 효율적인 검색 연산을 수행할 수 있고 새로운 값을 삽입하거나 기존 값을 삭제하는 작업도 효율적으로 수행할 수 있습니다. 
    

### 이진 탐색 트리를 활용한 실제 응용 사례나 문제 해결에 어떻게 활용?

- 웹 검색 엔진 및 텍스트 편집기
사용자의 입력에 따라 빠른 검색 결과나 자동완성 제안을 제공하기 위해 단어나  검색어를 정렬된 순서로 저장하여 사용자는 빠르고 효과적으로 원하는 정보를 검색하거나 입력을 완성할 수 있다.

## RDB와 NoSQL

- RDB (Relational Database)
사전에 정의된 테이블 형태의 데이터 모델을 사용 → 변경하기 어려운 정적 스키마
복잡한 쿼리 작성이 가능한 SQL 언어 사용. 다양한 데이터 조작 수행
수직 확장에 의존, ACID 원칙을 따라 데이터 일관성과 무결성을 보장
    - MySQL, PostgreSQL, Oracle
    - 엑셀 표처럼 생김
        
        
        | id | name | age |
        | --- | --- | --- |
        | 1 | 유정한 | 25 |
        | 2 | 민수 | 30 |
- NoSQL (Not Only SQL)
다양한 형태의 데이터 모델(문서형, 키-값형 등)을 제공 → 유연하게 변경 가능한 동적 스키마
모델별로 다른 쿼리 언어가 사용. 단순 검색 및 필터링 작업에 주로 이용
수평 확장으로 크거나 변화하는 환경에서 용이, BASE 원칙을 따라 높은 가용성과 확장성.
    - MongoDB, Redis, Cassandra, DynamoDB
    - JSON 문서처럼 생김
        
        ```json
        {
        "id": 1,
        "name": "유정한",
        "age": 25,
        "hobbies": ["코딩", "등산"]
        }
        ```
        

RDB는 엑셀처럼 테이블 형태로 데이터를 저장하고 미리 정해진 정적 구조이기 때문에 바꾸기 어렵습니다.
하지만 SQL이라는 언어로 복잡한 조건도 쉽게 조회가 가능합니다. 
반면, NoSQL은 표 형태가 아닌 문서나 키-값 같은 자유로운 형태로 저장하기 때문에 이후에 구조를 쉽게 바꿀 수 있습니다.
→ RDB는 정확하고 안정적인 데이터 관리에, NoSQL은 유연하고 빠른 확장이 필요한 상황에서 유리합니다.

# 오늘의 도전 과제와 해결 방법
- GCP서버와 vscode까지 연동하고 vllm을 사용하여 모델 성능을 할 수 있는 환경 설정을 마치고, 원래 사용할 계획이었던 Phi4-mini 모델을 돌려보니 성능이 엉망이였다.
  그래서 hugging face에서 제공하는 evaluate 라이브러리를 이용해서 BERT-score (precision, recall, f1)을 중점으로 Phi-4-mini, Phi-2, Mistral-7B 각각 측정해보았다.

  그제야 Pih-4는 너무 커서 서버에 안올라가고, Phi-4-mini는 vllm 지원하지 않고, phi-2는 점수들이 너무 낮아 성능이 좋지 않다는 것을 확인했다.
  결론은 크기도 너무 작지도, 크지도 않고 성능 측정 점수도 나쁘지 않은 Mistral-7B로 모델을 교체하기로 결정했다.

  이미 GCP, vscode, vLLM 모두 구축해놓았으면 좋았을텐데 후회가 된다.
